

#include "ina260.h"
#include <cstdint>
#include <gpiod.hpp>

namespace INA260_Driver {

/**
 * @brief  Class constructor. In order to make the class communicate with
 * sensor user should pass a valid I2C_Interface class instance! Also pass a
 * valid MPU6050Interface class instance to work on aquired data.
 * @param  comInterface I2C interface pointer
 * @param  inaInterface INA260 listener interface pointer.
 * @param  gpioPin GPIO pin that will listen for interrupts from the INA.
 * @retval none
 */
INA260::INA260(I2C_Interface *comInterface, INA260Interface *inaInterface,
               gpiod::line::offset _gpioPin)
    : gpioPin(_gpioPin) {
  if (comInterface)
    this->i2c = comInterface;
  if (inaInterface)
    this->ina260cb = inaInterface;
}

/**
 * @brief  This method wakes and configures the sensor to a specific
 * convertion time, averaging mode, operating mode and interupt type. it
 * returns whether the initialisation was successfull
 * @param  alert_mode Sets the interupt mode for the current sensor
 * @param  volt_conv_time Sets the conversion time for the voltage measurement
 * @param  curr_conv_time Sets the conversion time for the current measurement
 * @param  averaging_mode Sets the number of samples to average to produce the
 * reading.
 * @param  operating_mode Sets the operating mode of the sensor. Triggered or
 * continuous and what conversion is used for reading.
 * @retval i2c_status_t Success status
 */
i2c_status_t INA260::InitializeSensor(Alert_Conf alert_mode,
                                      Conv_Time volt_conv_time,
                                      Conv_Time curr_conv_time,
                                      Ave_Mode averaging_mode,
                                      Op_Mode operating_mode) {
  i2c_status_t result = AlertSet(alert_mode);

  if (result == I2C_STATUS_SUCCESS)
    result = CurrentConvTime(curr_conv_time);

  if (result == I2C_STATUS_SUCCESS)
    result = VoltageConvTime(volt_conv_time);

  if (result == I2C_STATUS_SUCCESS)
    result = AveragingMode(averaging_mode);

  if (result == I2C_STATUS_SUCCESS)
    result = OperatingMode(operating_mode);
  return result;
}

/**
 * @brief  This function will begin data aquisition in a separate thread.
 * @param  None
 * @retval None
 */
void INA260::begin(void) {
  dataAquisitionRunning = true;
  dataAquisitionThread = std::thread(&INA260::dataAquisition, this);
}

/**
 * @brief  This method stops data aquisition.
 * @param  None
 * @retval  None
 */
void INA260::end(void) {
  dataAquisitionRunning = false;
  dataAquisitionThread.join();
}

/**
 * @brief Data aquisition method that, in the loop, will block until and
 * interupt is generated by the INA260
 * @param None
 * @retval None
 */
void INA260::dataAquisition(void) {
  const std::filesystem::path chip_path("/dev/gpiochip4");

  auto request =
      gpiod::chip(chip_path)
          .prepare_request()
          .set_consumer("watch-line-value")
          .add_line_settings(
              gpioPin, gpiod::line_settings()
                           .set_direction(gpiod::line ::direction::INPUT)
                           .set_edge_detection(gpiod::line::edge ::FALLING))
          .do_request();
  gpiod::edge_event_buffer buffer(1);

  INA260Sample sample;

  while (dataAquisitionRunning) {
    sample.current = ReadCurrent();
    sample.voltage = ReadVoltage();

    ina260cb->hasSample(sample);

    request.read_edge_events(buffer);
  }
}

/**
 * @brief Read the voltage through the sensor.
 * @param  None
 * @retval float Voltage.
 */
float INA260::ReadVoltage(void) {
  i2c_status_t status;
  int16_t voltage_data = i2c->ReadRegisterWordBigEndian(
      INA260_ADDRESS, Sensor_Regs::VOLTAGE_REG, &status);
  i2c->ReadRegisterWordBigEndian(INA260_ADDRESS, Sensor_Regs::MASKEN_REG,
                                 &status);
  return ReadingBases::VOLTAGE * voltage_data;
}

/**
 * @brief Read the current through the sensor.
 * @param  None
 * @retval float Current.
 */
float INA260::ReadCurrent(void) {
  i2c_status_t status;
  int16_t current_data = i2c->ReadRegisterWordBigEndian(
      INA260_ADDRESS, Sensor_Regs::CURRENT_REG, &status);
  i2c->ReadRegisterWordBigEndian(INA260_ADDRESS, Sensor_Regs::MASKEN_REG,
                                 &status);
  return ReadingBases::CURRENT * current_data;
}

/**
 * @brief Read the power through the sensor.
 * @param  None
 * @retval float Power
 */
float INA260::ReadPower(void) {
  i2c_status_t status;
  int16_t power_data = i2c->ReadRegisterWordBigEndian(
      INA260_ADDRESS, Sensor_Regs::POWER_REG, &status);
  i2c->ReadRegisterWordBigEndian(INA260_ADDRESS, Sensor_Regs::MASKEN_REG,
                                 &status);
  return ReadingBases::POWER * power_data;
}

/**
 * @brief This method configures the interupt pin mode.
 * @param  Interupt pin mode.
 * @retval i2c_status_t
 */
i2c_status_t INA260::AlertSet(Alert_Conf alert_mode) {
  uint16_t alert_data;
  alert_data = (uint16_t)alert_mode << 8;
  return i2c->WriteRegisterWordBigEndian(INA260_ADDRESS,
                                         Sensor_Regs::MASKEN_REG, alert_data);
}

/**
 * @brief  This method configures the conversion time between samples for
 * voltage.
 * @param  convert_time Time between samples.
 * @retval i2c_status_t
 */
i2c_status_t INA260::CurrentConvTime(Conv_Time convert_time) {
  i2c_status_t status;
  uint16_t conv_time_reg = i2c->ReadRegisterWordBigEndian(
      INA260_ADDRESS, Sensor_Regs::CONF_REG, &status);
  uint16_t mask = ~0b0000000000111000;
  conv_time_reg = conv_time_reg & mask;
  conv_time_reg = conv_time_reg | ((uint16_t)convert_time << 3);
  return i2c->WriteRegisterWordBigEndian(INA260_ADDRESS, Sensor_Regs::CONF_REG,
                                         conv_time_reg);
}

/**
 * @brief  This method configures the operating mode. Can be continuous or
 * triggered and can depend on voltage or current.
 * @param  Operating mode.
 * @retval i2c_status_t
 */
i2c_status_t INA260::VoltageConvTime(Conv_Time convert_time) {
  i2c_status_t status;
  uint16_t conv_time_reg = i2c->ReadRegisterWordBigEndian(
      INA260_ADDRESS, Sensor_Regs::CONF_REG, &status);
  uint16_t mask = ~0b0000000111000000;
  conv_time_reg = conv_time_reg & mask;
  conv_time_reg = conv_time_reg | ((uint16_t)convert_time << 6);
  return i2c->WriteRegisterWordBigEndian(INA260_ADDRESS, Sensor_Regs::CONF_REG,
                                         conv_time_reg);
}

/**
 * @brief This method configures the interupt pin mode.
 * @param  Interupt pin mode.
 * @retval i2c_status_t
 */
i2c_status_t INA260::OperatingMode(Op_Mode operate_mode) {
  i2c_status_t status;
  uint16_t conf_reg_data = i2c->ReadRegisterWordBigEndian(
      INA260_ADDRESS, Sensor_Regs::CONF_REG, &status);
  uint16_t mask = ~0b0000000000000111;
  conf_reg_data = conf_reg_data & mask;
  conf_reg_data = conf_reg_data | ((uint16_t)operate_mode);
  std::cout << "Data sent to config register: " << std::hex << conf_reg_data
            << std::endl;
  return i2c->WriteRegisterWordBigEndian(INA260_ADDRESS, Sensor_Regs::CONF_REG,
                                         conf_reg_data);
}

/**
 * @brief  This method configures the conversion time between samples for
 * current.
 * @param  convert_time Time between samples.
 * @retval i2c_status_t
 */
i2c_status_t INA260::AveragingMode(Ave_Mode ave_setting) {
  i2c_status_t status;
  uint16_t conf_reg_data = i2c->ReadRegisterWordBigEndian(
      INA260_ADDRESS, Sensor_Regs::CONF_REG, &status);
  uint16_t mask = ~0b0000111000000000;
  conf_reg_data = conf_reg_data & mask;
  conf_reg_data = conf_reg_data | ((uint16_t)ave_setting << 9);
  return i2c->WriteRegisterWordBigEndian(INA260_ADDRESS, Sensor_Regs::CONF_REG,
                                         conf_reg_data);
}

} // namespace INA260_Driver
