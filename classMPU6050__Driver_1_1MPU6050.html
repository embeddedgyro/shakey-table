<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>ShakeyTable: MPU6050_Driver::MPU6050 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">ShakeyTable
   &#160;<span id="projectnumber">1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>MPU6050_Driver</b></li><li class="navelem"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html">MPU6050</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classMPU6050__Driver_1_1MPU6050-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MPU6050_Driver::MPU6050 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab1d73b0bb50578e266e842b58da9051a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ab1d73b0bb50578e266e842b58da9051a">MPU6050</a> (<a class="el" href="classI2C__Interface.html">I2C_Interface</a> *comInterface, <a class="el" href="classMPU6050__Driver_1_1MPU6050Interface.html">MPU6050Interface</a> *mpuInterface, gpiod::line::offset _gpioPin)</td></tr>
<tr class="memdesc:ab1d73b0bb50578e266e842b58da9051a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class constructor. In order to make the class communicate with sensor user should pass a valid <a class="el" href="classI2C__Interface.html">I2C_Interface</a> class instance! Also pass a valid <a class="el" href="classMPU6050__Driver_1_1MPU6050Interface.html" title="Callback interface where the callback needs to be implemented by the host application.">MPU6050Interface</a> class instance to work on aquired data.  <a href="classMPU6050__Driver_1_1MPU6050.html#ab1d73b0bb50578e266e842b58da9051a">More...</a><br /></td></tr>
<tr class="separator:ab1d73b0bb50578e266e842b58da9051a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267229ea1fc1e3d02eb503d068136fa8"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a267229ea1fc1e3d02eb503d068136fa8">InitializeSensor</a> (<a class="el" href="mpu6050_8h.html#a6074b2c5a2ea1df1f7f931d55e0bd711">Gyro_FS_t</a> gyroScale=Gyro_FS_t::FS_250_DPS, <a class="el" href="mpu6050_8h.html#adbb805fbc4ba6794ec6c603957b66f86">Accel_FS_t</a> accelScale=Accel_FS_t::FS_2G, <a class="el" href="mpu6050_8h.html#a68026e723630e8ce2bd1eb0a16b1fdaf">DLPF_t</a> DLPFconf=DLPF_t::BW_260Hz, uint8_t SRdiv=7, uint8_t INTconf=Regbits_INT_PIN_CFG::BIT_INT_RD_CLEAR, uint8_t INTenable=Regbits_INT_ENABLE::BIT_DATA_RDY_EN, float accelCalX=0, float accelCalY=0, float accelCalZ=1, float gyroCalX=0, float gyroCalY=0, float gyroCalZ=0)</td></tr>
<tr class="memdesc:a267229ea1fc1e3d02eb503d068136fa8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method wakes up the sensor and configures the accelerometer and gyroscope full scale renges with given parameters. It also configures the DLPF, sample rate divider, interrput configuration, and also calibrates the accelerometers and gyros. It returns the result of the process.  <a href="classMPU6050__Driver_1_1MPU6050.html#a267229ea1fc1e3d02eb503d068136fa8">More...</a><br /></td></tr>
<tr class="separator:a267229ea1fc1e3d02eb503d068136fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf211afbd98933d488deff8bfe88f1d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#abf211afbd98933d488deff8bfe88f1d4">begin</a> (void)</td></tr>
<tr class="memdesc:abf211afbd98933d488deff8bfe88f1d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function will begin data aquisition in a separate thread.  <a href="classMPU6050__Driver_1_1MPU6050.html#abf211afbd98933d488deff8bfe88f1d4">More...</a><br /></td></tr>
<tr class="separator:abf211afbd98933d488deff8bfe88f1d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f67c5f1aca34c1e24fbc5b8eb1d2324"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a6f67c5f1aca34c1e24fbc5b8eb1d2324">end</a> (void)</td></tr>
<tr class="memdesc:a6f67c5f1aca34c1e24fbc5b8eb1d2324"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method stops data aquisition.  <a href="classMPU6050__Driver_1_1MPU6050.html#a6f67c5f1aca34c1e24fbc5b8eb1d2324">More...</a><br /></td></tr>
<tr class="separator:a6f67c5f1aca34c1e24fbc5b8eb1d2324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac54bc4e13a5acafd1f3482a442285cde"><td class="memItemLeft" align="right" valign="top"><a id="ac54bc4e13a5acafd1f3482a442285cde"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ac54bc4e13a5acafd1f3482a442285cde">~MPU6050</a> ()</td></tr>
<tr class="memdesc:ac54bc4e13a5acafd1f3482a442285cde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class destructor. Simple calls <a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a6f67c5f1aca34c1e24fbc5b8eb1d2324" title="This method stops data aquisition.">end()</a> to stop data aquisition. <br /></td></tr>
<tr class="separator:ac54bc4e13a5acafd1f3482a442285cde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade93d7bce93550dcc0b1655f15e8e7c1"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ade93d7bce93550dcc0b1655f15e8e7c1">ReadAllRawData</a> (void)</td></tr>
<tr class="memdesc:ade93d7bce93550dcc0b1655f15e8e7c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method will read all raw sensor data (accel, gyro, temp) into the rawData array.  <a href="classMPU6050__Driver_1_1MPU6050.html#ade93d7bce93550dcc0b1655f15e8e7c1">More...</a><br /></td></tr>
<tr class="separator:ade93d7bce93550dcc0b1655f15e8e7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b710e84411c3e041cf2bf7bd0faf8d9"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a2b710e84411c3e041cf2bf7bd0faf8d9">WakeUpSensor</a> (void)</td></tr>
<tr class="memdesc:a2b710e84411c3e041cf2bf7bd0faf8d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method wakes the sensor up by cleraing the REG_PWR_MGMT_1 BIT_SLEEP. Power management 1 sensors default values is 0x40 so it will be in sleep mode when it's powered up.  <a href="classMPU6050__Driver_1_1MPU6050.html#a2b710e84411c3e041cf2bf7bd0faf8d9">More...</a><br /></td></tr>
<tr class="separator:a2b710e84411c3e041cf2bf7bd0faf8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e03c9cbdf0899f49fee4b0e4d01a0e"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a65e03c9cbdf0899f49fee4b0e4d01a0e">ResetSensor</a> (void)</td></tr>
<tr class="memdesc:a65e03c9cbdf0899f49fee4b0e4d01a0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method resets the sensor by simply setting the REG_PWR_MGMT_1 Device_Reset bit. After the sensor reset this bit will be cleared automatically.  <a href="classMPU6050__Driver_1_1MPU6050.html#a65e03c9cbdf0899f49fee4b0e4d01a0e">More...</a><br /></td></tr>
<tr class="separator:a65e03c9cbdf0899f49fee4b0e4d01a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab984441f83c718cf5c5c1bf019ea94ae"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ab984441f83c718cf5c5c1bf019ea94ae">SetGyroFullScale</a> (<a class="el" href="mpu6050_8h.html#a6074b2c5a2ea1df1f7f931d55e0bd711">Gyro_FS_t</a> gyroScale)</td></tr>
<tr class="memdesc:ab984441f83c718cf5c5c1bf019ea94ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for configuring the gyroscope full scale range. Check gyro_full_scale_range_t for available scales.  <a href="classMPU6050__Driver_1_1MPU6050.html#ab984441f83c718cf5c5c1bf019ea94ae">More...</a><br /></td></tr>
<tr class="separator:ab984441f83c718cf5c5c1bf019ea94ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406f1b5fa42bb13c1fe6c2b1df9f3070"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpu6050_8h.html#a6074b2c5a2ea1df1f7f931d55e0bd711">Gyro_FS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a406f1b5fa42bb13c1fe6c2b1df9f3070">GetGyroFullScale</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a406f1b5fa42bb13c1fe6c2b1df9f3070"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the gyroscope full scale range. Check gyro_full_scale_range_t for available scales. It basically reads the Gyro configuration register and returns the full scale range.  <a href="classMPU6050__Driver_1_1MPU6050.html#a406f1b5fa42bb13c1fe6c2b1df9f3070">More...</a><br /></td></tr>
<tr class="separator:a406f1b5fa42bb13c1fe6c2b1df9f3070"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a558a7bee8e4eb5018766739379a6b909"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a558a7bee8e4eb5018766739379a6b909">GetGyro_X_Raw</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a558a7bee8e4eb5018766739379a6b909"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the latest gyroscope X axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and gyroscope full scale range is set to desired range before reading the values.  <a href="classMPU6050__Driver_1_1MPU6050.html#a558a7bee8e4eb5018766739379a6b909">More...</a><br /></td></tr>
<tr class="separator:a558a7bee8e4eb5018766739379a6b909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43474a84750ba33d4f2ccd1e1f99ef51"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a43474a84750ba33d4f2ccd1e1f99ef51">GetGyro_Y_Raw</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a43474a84750ba33d4f2ccd1e1f99ef51"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the latest gyroscope Y axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and gyroscope full scale range is set to desired range before reading the values.  <a href="classMPU6050__Driver_1_1MPU6050.html#a43474a84750ba33d4f2ccd1e1f99ef51">More...</a><br /></td></tr>
<tr class="separator:a43474a84750ba33d4f2ccd1e1f99ef51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf9a58f90dfbc059e5fc5d5295f2f919"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#abf9a58f90dfbc059e5fc5d5295f2f919">GetGyro_Z_Raw</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:abf9a58f90dfbc059e5fc5d5295f2f919"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the latest gyroscope Z axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and gyroscope full scale range is set to desired range before reading the values.  <a href="classMPU6050__Driver_1_1MPU6050.html#abf9a58f90dfbc059e5fc5d5295f2f919">More...</a><br /></td></tr>
<tr class="separator:abf9a58f90dfbc059e5fc5d5295f2f919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050c46f31e9c88e95b744918afa00afd"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a050c46f31e9c88e95b744918afa00afd">SetAccelFullScale</a> (<a class="el" href="mpu6050_8h.html#adbb805fbc4ba6794ec6c603957b66f86">Accel_FS_t</a> accelScale)</td></tr>
<tr class="memdesc:a050c46f31e9c88e95b744918afa00afd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for configuring the accelerometer full scale range. Check accel_full_scale_range_t for available scales.  <a href="classMPU6050__Driver_1_1MPU6050.html#a050c46f31e9c88e95b744918afa00afd">More...</a><br /></td></tr>
<tr class="separator:a050c46f31e9c88e95b744918afa00afd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb642ce658369a5e1a037dcef7309bbf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpu6050_8h.html#adbb805fbc4ba6794ec6c603957b66f86">Accel_FS_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#acb642ce658369a5e1a037dcef7309bbf">GetAccelFullScale</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:acb642ce658369a5e1a037dcef7309bbf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the acceleromteter full scale range. Check accel_full_scale_range_t for available scales. It basically reads the Accel configuration register and returns the full scale range.  <a href="classMPU6050__Driver_1_1MPU6050.html#acb642ce658369a5e1a037dcef7309bbf">More...</a><br /></td></tr>
<tr class="separator:acb642ce658369a5e1a037dcef7309bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870ce380e742c3c964dc1b23e7d8576a"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a870ce380e742c3c964dc1b23e7d8576a">GetAccel_X_Raw</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a870ce380e742c3c964dc1b23e7d8576a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the latest accelerometer X axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and accelerometer full scale range is set to desired range, before reading the values.  <a href="classMPU6050__Driver_1_1MPU6050.html#a870ce380e742c3c964dc1b23e7d8576a">More...</a><br /></td></tr>
<tr class="separator:a870ce380e742c3c964dc1b23e7d8576a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b8d87cbf2e23ca5821873a92d0a2db"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a16b8d87cbf2e23ca5821873a92d0a2db">GetAccel_Y_Raw</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a16b8d87cbf2e23ca5821873a92d0a2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the latest accelerometer Y axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and accelerometer full scale range is set to desired range, before reading the values.  <a href="classMPU6050__Driver_1_1MPU6050.html#a16b8d87cbf2e23ca5821873a92d0a2db">More...</a><br /></td></tr>
<tr class="separator:a16b8d87cbf2e23ca5821873a92d0a2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3d4c116de5d81642f6d6961b92277d"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a2c3d4c116de5d81642f6d6961b92277d">GetAccel_Z_Raw</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a2c3d4c116de5d81642f6d6961b92277d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the latest accelerometer Z axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and accelerometer full scale range is set to desired range, before reading the values.  <a href="classMPU6050__Driver_1_1MPU6050.html#a2c3d4c116de5d81642f6d6961b92277d">More...</a><br /></td></tr>
<tr class="separator:a2c3d4c116de5d81642f6d6961b92277d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1311d6642dd43f9132598f7f84015954"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a1311d6642dd43f9132598f7f84015954">GetTemperature_Celcius</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a1311d6642dd43f9132598f7f84015954"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the latest temperature value from the sensor. scale range is set to desired range, before reading the values.  <a href="classMPU6050__Driver_1_1MPU6050.html#a1311d6642dd43f9132598f7f84015954">More...</a><br /></td></tr>
<tr class="separator:a1311d6642dd43f9132598f7f84015954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab20bbcc5f584fe698060066d933e0081"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ab20bbcc5f584fe698060066d933e0081">SetGyro_X_Offset</a> (int16_t offset)</td></tr>
<tr class="memdesc:ab20bbcc5f584fe698060066d933e0081"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for setting the gyroscope X axis offset value. Offset is using in the sensor calibration routine.  <a href="classMPU6050__Driver_1_1MPU6050.html#ab20bbcc5f584fe698060066d933e0081">More...</a><br /></td></tr>
<tr class="separator:ab20bbcc5f584fe698060066d933e0081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abee892bc90c31e7ff8f4e413acd29a3f"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#abee892bc90c31e7ff8f4e413acd29a3f">GetGyro_X_Offset</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:abee892bc90c31e7ff8f4e413acd29a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the gyroscope X axis offset value.  <a href="classMPU6050__Driver_1_1MPU6050.html#abee892bc90c31e7ff8f4e413acd29a3f">More...</a><br /></td></tr>
<tr class="separator:abee892bc90c31e7ff8f4e413acd29a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b64f45c3dc25303c0fbee8fa112e034"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a5b64f45c3dc25303c0fbee8fa112e034">SetGyro_Y_Offset</a> (int16_t offset)</td></tr>
<tr class="memdesc:a5b64f45c3dc25303c0fbee8fa112e034"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for setting the gyroscope Y axis offset value. Offset is using in the sensor calibration routine.  <a href="classMPU6050__Driver_1_1MPU6050.html#a5b64f45c3dc25303c0fbee8fa112e034">More...</a><br /></td></tr>
<tr class="separator:a5b64f45c3dc25303c0fbee8fa112e034"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58c0f258587f621b1fb3219790a77215"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a58c0f258587f621b1fb3219790a77215">GetGyro_Y_Offset</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a58c0f258587f621b1fb3219790a77215"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the gyroscope Y axis offset value.  <a href="classMPU6050__Driver_1_1MPU6050.html#a58c0f258587f621b1fb3219790a77215">More...</a><br /></td></tr>
<tr class="separator:a58c0f258587f621b1fb3219790a77215"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7803c59727c134c378f696ad1b25945d"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a7803c59727c134c378f696ad1b25945d">SetGyro_Z_Offset</a> (int16_t offset)</td></tr>
<tr class="memdesc:a7803c59727c134c378f696ad1b25945d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for setting the gyroscope Z axis offset value. Offset is using in the sensor calibration routine.  <a href="classMPU6050__Driver_1_1MPU6050.html#a7803c59727c134c378f696ad1b25945d">More...</a><br /></td></tr>
<tr class="separator:a7803c59727c134c378f696ad1b25945d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39626a74e18356c62eb1ee2469c224ef"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a39626a74e18356c62eb1ee2469c224ef">GetGyro_Z_Offset</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a39626a74e18356c62eb1ee2469c224ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the gyroscope Z axis offset value.  <a href="classMPU6050__Driver_1_1MPU6050.html#a39626a74e18356c62eb1ee2469c224ef">More...</a><br /></td></tr>
<tr class="separator:a39626a74e18356c62eb1ee2469c224ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae91c57f592f8adf2193a7d5ffbed2f4"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#aae91c57f592f8adf2193a7d5ffbed2f4">Calibrate_Gyro_Registers</a> (int16_t targetX=0, int16_t targetY=0, int16_t targetZ=0)</td></tr>
<tr class="memdesc:aae91c57f592f8adf2193a7d5ffbed2f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for calibrating the gyroscope registers to given target values.  <a href="classMPU6050__Driver_1_1MPU6050.html#aae91c57f592f8adf2193a7d5ffbed2f4">More...</a><br /></td></tr>
<tr class="separator:aae91c57f592f8adf2193a7d5ffbed2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a575402732b740e829c575e9a18807020"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a575402732b740e829c575e9a18807020">GetGyro_DPS_Constant</a> (<a class="el" href="mpu6050_8h.html#a6074b2c5a2ea1df1f7f931d55e0bd711">Gyro_FS_t</a> gyroRange)</td></tr>
<tr class="memdesc:a575402732b740e829c575e9a18807020"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the DPS (Degree Per Second) coversion value depending on the gyroscope full scale range. DPS value is used to convert raw sensor value to angular velocity for orientation related calculations.  <a href="classMPU6050__Driver_1_1MPU6050.html#a575402732b740e829c575e9a18807020">More...</a><br /></td></tr>
<tr class="separator:a575402732b740e829c575e9a18807020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a307e5149054d25aa053c11438f782ad9"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a307e5149054d25aa053c11438f782ad9">SetAccel_X_Offset</a> (int16_t offset)</td></tr>
<tr class="memdesc:a307e5149054d25aa053c11438f782ad9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for setting the accelerometer X axis offset value. Offset is using in the sensor calibration routine.  <a href="classMPU6050__Driver_1_1MPU6050.html#a307e5149054d25aa053c11438f782ad9">More...</a><br /></td></tr>
<tr class="separator:a307e5149054d25aa053c11438f782ad9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdd083c5308d89f75d316460726dc5e"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a5cdd083c5308d89f75d316460726dc5e">GetAccel_X_Offset</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a5cdd083c5308d89f75d316460726dc5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the accelerometer X axis offset value.  <a href="classMPU6050__Driver_1_1MPU6050.html#a5cdd083c5308d89f75d316460726dc5e">More...</a><br /></td></tr>
<tr class="separator:a5cdd083c5308d89f75d316460726dc5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7703918ba2ac7f85942a27a6f7f039"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a2d7703918ba2ac7f85942a27a6f7f039">SetAccel_Y_Offset</a> (int16_t offset)</td></tr>
<tr class="memdesc:a2d7703918ba2ac7f85942a27a6f7f039"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for setting the accelerometer Y axis offset value. Offset is using in the sensor calibration routine.  <a href="classMPU6050__Driver_1_1MPU6050.html#a2d7703918ba2ac7f85942a27a6f7f039">More...</a><br /></td></tr>
<tr class="separator:a2d7703918ba2ac7f85942a27a6f7f039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113d86c4fbb52c37b68d58048689eec5"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a113d86c4fbb52c37b68d58048689eec5">GetAccel_Y_Offset</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a113d86c4fbb52c37b68d58048689eec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the accelerometer Y axis offset value.  <a href="classMPU6050__Driver_1_1MPU6050.html#a113d86c4fbb52c37b68d58048689eec5">More...</a><br /></td></tr>
<tr class="separator:a113d86c4fbb52c37b68d58048689eec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48b4595994f56460ef1cbd3ee69a9c52"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a48b4595994f56460ef1cbd3ee69a9c52">SetAccel_Z_Offset</a> (int16_t offset)</td></tr>
<tr class="memdesc:a48b4595994f56460ef1cbd3ee69a9c52"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for setting the accelerometer Z axis offset value. Offset is using in the sensor calibration routine.  <a href="classMPU6050__Driver_1_1MPU6050.html#a48b4595994f56460ef1cbd3ee69a9c52">More...</a><br /></td></tr>
<tr class="separator:a48b4595994f56460ef1cbd3ee69a9c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa29c41ae52bb89018dc936fea49d4588"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#aa29c41ae52bb89018dc936fea49d4588">GetAccel_Z_Offset</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:aa29c41ae52bb89018dc936fea49d4588"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for getting the accelerometer Z axis offset value.  <a href="classMPU6050__Driver_1_1MPU6050.html#aa29c41ae52bb89018dc936fea49d4588">More...</a><br /></td></tr>
<tr class="separator:aa29c41ae52bb89018dc936fea49d4588"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40cc9aea6f480ad0e6e7ad35f9e2e926"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a40cc9aea6f480ad0e6e7ad35f9e2e926">Calibrate_Accel_Registers</a> (float targetX_MG=0.0f, float targetY_MG=0.0f, float targetZ_MG=1.0f)</td></tr>
<tr class="memdesc:a40cc9aea6f480ad0e6e7ad35f9e2e926"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method used for calibrating the accelerometer registers to given target values.  <a href="classMPU6050__Driver_1_1MPU6050.html#a40cc9aea6f480ad0e6e7ad35f9e2e926">More...</a><br /></td></tr>
<tr class="separator:a40cc9aea6f480ad0e6e7ad35f9e2e926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad922d228387318d445ebb57b5afa66e3"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ad922d228387318d445ebb57b5afa66e3">GetAccel_MG_Constant</a> (<a class="el" href="mpu6050_8h.html#adbb805fbc4ba6794ec6c603957b66f86">Accel_FS_t</a> accelRange)</td></tr>
<tr class="memdesc:ad922d228387318d445ebb57b5afa66e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method returns the MG (Gravity) coversion value depending on the accelerometer full scale range. MG value is used to convert raw sensor value to Gravity for acceleration related calculations.  <a href="classMPU6050__Driver_1_1MPU6050.html#ad922d228387318d445ebb57b5afa66e3">More...</a><br /></td></tr>
<tr class="separator:ad922d228387318d445ebb57b5afa66e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe4393d5ad126f6734f8c090fd5e6c7"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#abfe4393d5ad126f6734f8c090fd5e6c7">SetGyro_SampleRateDivider</a> (uint8_t sampleRate)</td></tr>
<tr class="memdesc:abfe4393d5ad126f6734f8c090fd5e6c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the gyroscope sample rate divider. Once the sample rate divider set, actual sample rate can be found with this formula: Actual sample rate = Gyroscope Output Rate / (1 + sampleRate) Keep in mind that Gyroscope Output Rate = 8kHz when the DLPF (digital low pass filter) is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled. Accel sample rate is constantly 1 kHz.  <a href="classMPU6050__Driver_1_1MPU6050.html#abfe4393d5ad126f6734f8c090fd5e6c7">More...</a><br /></td></tr>
<tr class="separator:abfe4393d5ad126f6734f8c090fd5e6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3973b32ec709a5ceb69952cd5784472d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a3973b32ec709a5ceb69952cd5784472d">GetGyro_SampleRateDivider</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a3973b32ec709a5ceb69952cd5784472d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the gyroscope sample rate divider. Actual sample rate = Gyroscope Output Rate / (1 + sampleRate) Keep in mind that Gyroscope Output Rate = 8kHz when the DLPF (digital low pass filter) is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled. Accel sample rate is constantly 1 kHz.  <a href="classMPU6050__Driver_1_1MPU6050.html#a3973b32ec709a5ceb69952cd5784472d">More...</a><br /></td></tr>
<tr class="separator:a3973b32ec709a5ceb69952cd5784472d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94fd2a72ce9b39bd84dca9f6b10b0960"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a94fd2a72ce9b39bd84dca9f6b10b0960">SetSensor_DLPF_Config</a> (<a class="el" href="mpu6050_8h.html#a68026e723630e8ce2bd1eb0a16b1fdaf">DLPF_t</a> dlpfConfig)</td></tr>
<tr class="memdesc:a94fd2a72ce9b39bd84dca9f6b10b0960"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sensor digital low pass filter values. Tighter bandwitdh configs will generate more delay on the sensor outputs (check sensor datasheet). Keep in mind that default Gyroscope sample rate is 8 kHz but if we set DLPF config different than 0 it will be 1 kHz by default unless if we make an extra configuration to Sample Rate Divider.  <a href="classMPU6050__Driver_1_1MPU6050.html#a94fd2a72ce9b39bd84dca9f6b10b0960">More...</a><br /></td></tr>
<tr class="separator:a94fd2a72ce9b39bd84dca9f6b10b0960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4eadeb5b10c3e85e583248bb13d2618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="mpu6050_8h.html#a68026e723630e8ce2bd1eb0a16b1fdaf">DLPF_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ad4eadeb5b10c3e85e583248bb13d2618">GetSensor_DLPF_Config</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:ad4eadeb5b10c3e85e583248bb13d2618"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current sensor digital low pass filter configuration.  <a href="classMPU6050__Driver_1_1MPU6050.html#ad4eadeb5b10c3e85e583248bb13d2618">More...</a><br /></td></tr>
<tr class="separator:ad4eadeb5b10c3e85e583248bb13d2618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f6679d71e1968e463e7e8d419bdf49"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a63f6679d71e1968e463e7e8d419bdf49">GetSensor_CurrentSampleRate_Hz</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a63f6679d71e1968e463e7e8d419bdf49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the current sensor sample rate. In order to do this, method reads Sample Rate Divider (0x19) and DLPF Config (0x1A) registers.  <a href="classMPU6050__Driver_1_1MPU6050.html#a63f6679d71e1968e463e7e8d419bdf49">More...</a><br /></td></tr>
<tr class="separator:a63f6679d71e1968e463e7e8d419bdf49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90893e458d8c6fe5a9a22c3c24c164c"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ad90893e458d8c6fe5a9a22c3c24c164c">GetSensor_FIFOCount</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:ad90893e458d8c6fe5a9a22c3c24c164c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the number of bytes written in the sensor FIFO buffers.  <a href="classMPU6050__Driver_1_1MPU6050.html#ad90893e458d8c6fe5a9a22c3c24c164c">More...</a><br /></td></tr>
<tr class="separator:ad90893e458d8c6fe5a9a22c3c24c164c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66dcaf2d341a78c4ba4b6ce9fbf4cc8"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#aa66dcaf2d341a78c4ba4b6ce9fbf4cc8">GetSensor_InterruptEnable</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:aa66dcaf2d341a78c4ba4b6ce9fbf4cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the INT_ENABLE register value.  <a href="classMPU6050__Driver_1_1MPU6050.html#aa66dcaf2d341a78c4ba4b6ce9fbf4cc8">More...</a><br /></td></tr>
<tr class="separator:aa66dcaf2d341a78c4ba4b6ce9fbf4cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9eecdde5c431c18ba916e51bbb44c34"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ae9eecdde5c431c18ba916e51bbb44c34">SetSensor_InterruptEnable</a> (uint8_t enabledInterrupts)</td></tr>
<tr class="memdesc:ae9eecdde5c431c18ba916e51bbb44c34"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sensor INT_ENABLE register with given value.  <a href="classMPU6050__Driver_1_1MPU6050.html#ae9eecdde5c431c18ba916e51bbb44c34">More...</a><br /></td></tr>
<tr class="separator:ae9eecdde5c431c18ba916e51bbb44c34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d7645b5c99d12af2b5c77b0f0cd4308"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a8d7645b5c99d12af2b5c77b0f0cd4308">GetSensor_FIFO_Config</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a8d7645b5c99d12af2b5c77b0f0cd4308"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sensor FIFO configuration. Use Regbits_FIFO_EN as bitmask to check which samples enabled in the FIFO reading.  <a href="classMPU6050__Driver_1_1MPU6050.html#a8d7645b5c99d12af2b5c77b0f0cd4308">More...</a><br /></td></tr>
<tr class="separator:a8d7645b5c99d12af2b5c77b0f0cd4308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7bc69264354de42675fe46789040aea"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#ae7bc69264354de42675fe46789040aea">SetSensor_FIFO_Config</a> (uint8_t fifoConfigVal)</td></tr>
<tr class="memdesc:ae7bc69264354de42675fe46789040aea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sensor FIFO configuration.  <a href="classMPU6050__Driver_1_1MPU6050.html#ae7bc69264354de42675fe46789040aea">More...</a><br /></td></tr>
<tr class="separator:ae7bc69264354de42675fe46789040aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea4952ae0e6844d2e08f5ebce7f89c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a0ea4952ae0e6844d2e08f5ebce7f89c2">GetSensor_FIFO_Enable</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a0ea4952ae0e6844d2e08f5ebce7f89c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sensor FIFO enable bit in USER_CTRL register.  <a href="classMPU6050__Driver_1_1MPU6050.html#a0ea4952ae0e6844d2e08f5ebce7f89c2">More...</a><br /></td></tr>
<tr class="separator:a0ea4952ae0e6844d2e08f5ebce7f89c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbde7961817c56ac32fe2f0303ccd920"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#abbde7961817c56ac32fe2f0303ccd920">SetSensor_FIFO_Enable</a> (bool state)</td></tr>
<tr class="memdesc:abbde7961817c56ac32fe2f0303ccd920"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sensor FIFO enable bit in USER_CTRL register.  <a href="classMPU6050__Driver_1_1MPU6050.html#abbde7961817c56ac32fe2f0303ccd920">More...</a><br /></td></tr>
<tr class="separator:abbde7961817c56ac32fe2f0303ccd920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a279089d89ce308aab4e2ff4fed4478b1"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a279089d89ce308aab4e2ff4fed4478b1">Reset_Sensor_FIFO</a> (void)</td></tr>
<tr class="memdesc:a279089d89ce308aab4e2ff4fed4478b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function resets the sensor FIFO.  <a href="classMPU6050__Driver_1_1MPU6050.html#a279089d89ce308aab4e2ff4fed4478b1">More...</a><br /></td></tr>
<tr class="separator:a279089d89ce308aab4e2ff4fed4478b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b2d31a71051e11e833ef2f4e9d1796"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a87b2d31a71051e11e833ef2f4e9d1796">GetSensor_InterruptStatus</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a87b2d31a71051e11e833ef2f4e9d1796"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function gets the sensor interrput status (INT_STATUS) register.  <a href="classMPU6050__Driver_1_1MPU6050.html#a87b2d31a71051e11e833ef2f4e9d1796">More...</a><br /></td></tr>
<tr class="separator:a87b2d31a71051e11e833ef2f4e9d1796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ee2b1262daaaf93dc79e3c0f2cad59"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a43ee2b1262daaaf93dc79e3c0f2cad59">GetSensor_FIFO_Data</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a43ee2b1262daaaf93dc79e3c0f2cad59"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function reads 1 byte from sensor FIFO data register.  <a href="classMPU6050__Driver_1_1MPU6050.html#a43ee2b1262daaaf93dc79e3c0f2cad59">More...</a><br /></td></tr>
<tr class="separator:a43ee2b1262daaaf93dc79e3c0f2cad59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772cb0310b20811ac24b681fe3ecd4d0"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#a772cb0310b20811ac24b681fe3ecd4d0">GetSensor_InterruptPinConfig</a> (i2c_status_t *error)</td></tr>
<tr class="memdesc:a772cb0310b20811ac24b681fe3ecd4d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function returns sensor interrupt pin config register value.  <a href="classMPU6050__Driver_1_1MPU6050.html#a772cb0310b20811ac24b681fe3ecd4d0">More...</a><br /></td></tr>
<tr class="separator:a772cb0310b20811ac24b681fe3ecd4d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab75767c5515e9f57c04bc0635dc9f5"><td class="memItemLeft" align="right" valign="top">i2c_status_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMPU6050__Driver_1_1MPU6050.html#acab75767c5515e9f57c04bc0635dc9f5">SetSensor_InterruptPinConfig</a> (uint8_t intPinConfig)</td></tr>
<tr class="memdesc:acab75767c5515e9f57c04bc0635dc9f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function sets the sensor interrupt pin config register.  <a href="classMPU6050__Driver_1_1MPU6050.html#acab75767c5515e9f57c04bc0635dc9f5">More...</a><br /></td></tr>
<tr class="separator:acab75767c5515e9f57c04bc0635dc9f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab1d73b0bb50578e266e842b58da9051a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d73b0bb50578e266e842b58da9051a">&#9670;&nbsp;</a></span>MPU6050()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPU6050_Driver::MPU6050::MPU6050 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classI2C__Interface.html">I2C_Interface</a> *&#160;</td>
          <td class="paramname"><em>comInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMPU6050__Driver_1_1MPU6050Interface.html">MPU6050Interface</a> *&#160;</td>
          <td class="paramname"><em>mpuInterface</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gpiod::line::offset&#160;</td>
          <td class="paramname"><em>_gpioPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Class constructor. In order to make the class communicate with sensor user should pass a valid <a class="el" href="classI2C__Interface.html">I2C_Interface</a> class instance! Also pass a valid <a class="el" href="classMPU6050__Driver_1_1MPU6050Interface.html" title="Callback interface where the callback needs to be implemented by the host application.">MPU6050Interface</a> class instance to work on aquired data. </p>
<p>Class constructor. In order to make the class communicate with sensor user should pass a valid <a class="el" href="classI2C__Interface.html">I2C_Interface</a> class instance!</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comInterface</td><td>I2C interface pointer </td></tr>
    <tr><td class="paramname">mpuInterface</td><td><a class="el" href="classMPU6050__Driver_1_1MPU6050.html">MPU6050</a> listener interface pointer. </td></tr>
    <tr><td class="paramname">gpioPin</td><td>GPIO pin that will listen for interrupts from the MPU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comInterface</td><td>I2C interface pointer </td></tr>
    <tr><td class="paramname">mpuInterface</td><td><a class="el" href="classMPU6050__Driver_1_1MPU6050.html">MPU6050</a> interface pointer </td></tr>
    <tr><td class="paramname">gpioPin</td><td>GPIO pin that will listen for interrupts from the MPU. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abf211afbd98933d488deff8bfe88f1d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf211afbd98933d488deff8bfe88f1d4">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPU6050_Driver::MPU6050::begin </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function will begin data aquisition in a separate thread. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>Begin dataAquisition() method in a separate thread in a running state. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a40cc9aea6f480ad0e6e7ad35f9e2e926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40cc9aea6f480ad0e6e7ad35f9e2e926">&#9670;&nbsp;</a></span>Calibrate_Accel_Registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::Calibrate_Accel_Registers </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>targetX_MG</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>targetY_MG</em> = <code>0.0f</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>targetZ_MG</em> = <code>1.0f</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for calibrating the accelerometer registers to given target values. </p>
<p>This method used for calibrating the accelerometer registers to given target values. Even if the official calibration method in the invensense application notes are tried, it didnt work as expected. So there is another method implemented to calibrate accelerometer registers automatically. It works with the similar concept of binary search algorithm (setting a range and narrowing on each step).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetX</td><td>target value for accelerometer X axis register in MG so 1.0f means 1G </td></tr>
    <tr><td class="paramname">targetY</td><td>target value for accelerometer Y axis register in MG </td></tr>
    <tr><td class="paramname">targetZ</td><td>target value for accelerometer Z axis register in MG </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aae91c57f592f8adf2193a7d5ffbed2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae91c57f592f8adf2193a7d5ffbed2f4">&#9670;&nbsp;</a></span>Calibrate_Gyro_Registers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::Calibrate_Gyro_Registers </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>targetX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>targetY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>targetZ</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for calibrating the gyroscope registers to given target values. </p>
<p>This method used for calibrating the gyroscope registers to given target values. Its VERY important to mention that when you call this method make sure that the sensor is standing statically (no vibrations, no rotations, no movement etc.) otherwise you will end up with wrong calibration values! TODO: Use more detailed return type about the calibration status to inform user about the failure (which step it failed and why etc.).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">targetX</td><td>target value for gyroscope X axis register </td></tr>
    <tr><td class="paramname">targetY</td><td>target value for gyroscope Y axis register </td></tr>
    <tr><td class="paramname">targetZ</td><td>target value for gyroscope Z axis register </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6f67c5f1aca34c1e24fbc5b8eb1d2324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f67c5f1aca34c1e24fbc5b8eb1d2324">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MPU6050_Driver::MPU6050::end </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method stops data aquisition. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">None</td><td>Stop dataAquisition() method and close the thread running it. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad922d228387318d445ebb57b5afa66e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad922d228387318d445ebb57b5afa66e3">&#9670;&nbsp;</a></span>GetAccel_MG_Constant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MPU6050_Driver::MPU6050::GetAccel_MG_Constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mpu6050_8h.html#adbb805fbc4ba6794ec6c603957b66f86">Accel_FS_t</a>&#160;</td>
          <td class="paramname"><em>accelRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns the MG (Gravity) coversion value depending on the accelerometer full scale range. MG value is used to convert raw sensor value to Gravity for acceleration related calculations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accelRange</td><td>Configured accelerometer full scale range </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5cdd083c5308d89f75d316460726dc5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdd083c5308d89f75d316460726dc5e">&#9670;&nbsp;</a></span>GetAccel_X_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetAccel_X_Offset </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the accelerometer X axis offset value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a870ce380e742c3c964dc1b23e7d8576a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870ce380e742c3c964dc1b23e7d8576a">&#9670;&nbsp;</a></span>GetAccel_X_Raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetAccel_X_Raw </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the latest accelerometer X axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and accelerometer full scale range is set to desired range, before reading the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Error state of process </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>X axis RAW acceleration value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a113d86c4fbb52c37b68d58048689eec5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113d86c4fbb52c37b68d58048689eec5">&#9670;&nbsp;</a></span>GetAccel_Y_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetAccel_Y_Offset </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the accelerometer Y axis offset value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a16b8d87cbf2e23ca5821873a92d0a2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b8d87cbf2e23ca5821873a92d0a2db">&#9670;&nbsp;</a></span>GetAccel_Y_Raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetAccel_Y_Raw </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the latest accelerometer Y axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and accelerometer full scale range is set to desired range, before reading the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Error state of process </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>Y axis RAW acceleration value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa29c41ae52bb89018dc936fea49d4588"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa29c41ae52bb89018dc936fea49d4588">&#9670;&nbsp;</a></span>GetAccel_Z_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetAccel_Z_Offset </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the accelerometer Z axis offset value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c3d4c116de5d81642f6d6961b92277d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3d4c116de5d81642f6d6961b92277d">&#9670;&nbsp;</a></span>GetAccel_Z_Raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetAccel_Z_Raw </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the latest accelerometer Z axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and accelerometer full scale range is set to desired range, before reading the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Error state of process </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>Z axis RAW acceleration value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acb642ce658369a5e1a037dcef7309bbf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb642ce658369a5e1a037dcef7309bbf">&#9670;&nbsp;</a></span>GetAccelFullScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpu6050_8h.html#adbb805fbc4ba6794ec6c603957b66f86">Accel_FS_t</a> MPU6050_Driver::MPU6050::GetAccelFullScale </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the acceleromteter full scale range. Check accel_full_scale_range_t for available scales. It basically reads the Accel configuration register and returns the full scale range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the sensor reading process </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">accel_full_scale_range_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a575402732b740e829c575e9a18807020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a575402732b740e829c575e9a18807020">&#9670;&nbsp;</a></span>GetGyro_DPS_Constant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MPU6050_Driver::MPU6050::GetGyro_DPS_Constant </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mpu6050_8h.html#a6074b2c5a2ea1df1f7f931d55e0bd711">Gyro_FS_t</a>&#160;</td>
          <td class="paramname"><em>gyroRange</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method returns the DPS (Degree Per Second) coversion value depending on the gyroscope full scale range. DPS value is used to convert raw sensor value to angular velocity for orientation related calculations. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gyroRange</td><td>Configured gyro full scale range </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3973b32ec709a5ceb69952cd5784472d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3973b32ec709a5ceb69952cd5784472d">&#9670;&nbsp;</a></span>GetGyro_SampleRateDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MPU6050_Driver::MPU6050::GetGyro_SampleRateDivider </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the gyroscope sample rate divider. Actual sample rate = Gyroscope Output Rate / (1 + sampleRate) Keep in mind that Gyroscope Output Rate = 8kHz when the DLPF (digital low pass filter) is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled. Accel sample rate is constantly 1 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint8_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abee892bc90c31e7ff8f4e413acd29a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abee892bc90c31e7ff8f4e413acd29a3f">&#9670;&nbsp;</a></span>GetGyro_X_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetGyro_X_Offset </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the gyroscope X axis offset value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a558a7bee8e4eb5018766739379a6b909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a558a7bee8e4eb5018766739379a6b909">&#9670;&nbsp;</a></span>GetGyro_X_Raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetGyro_X_Raw </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the latest gyroscope X axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and gyroscope full scale range is set to desired range before reading the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Error state of process </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>X axis RAW gyroscope value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58c0f258587f621b1fb3219790a77215"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58c0f258587f621b1fb3219790a77215">&#9670;&nbsp;</a></span>GetGyro_Y_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetGyro_Y_Offset </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the gyroscope Y axis offset value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43474a84750ba33d4f2ccd1e1f99ef51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43474a84750ba33d4f2ccd1e1f99ef51">&#9670;&nbsp;</a></span>GetGyro_Y_Raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetGyro_Y_Raw </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the latest gyroscope Y axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and gyroscope full scale range is set to desired range before reading the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Error state of process </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>Y axis RAW gyroscope value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a39626a74e18356c62eb1ee2469c224ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39626a74e18356c62eb1ee2469c224ef">&#9670;&nbsp;</a></span>GetGyro_Z_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetGyro_Z_Offset </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the gyroscope Z axis offset value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abf9a58f90dfbc059e5fc5d5295f2f919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf9a58f90dfbc059e5fc5d5295f2f919">&#9670;&nbsp;</a></span>GetGyro_Z_Raw()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t MPU6050_Driver::MPU6050::GetGyro_Z_Raw </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the latest gyroscope Z axis RAW value from the sensor. Make sure that sensor is not in sleeping mode and gyroscope full scale range is set to desired range before reading the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Error state of process </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">int16_t</td><td>Z axis RAW gyroscope value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a406f1b5fa42bb13c1fe6c2b1df9f3070"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406f1b5fa42bb13c1fe6c2b1df9f3070">&#9670;&nbsp;</a></span>GetGyroFullScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpu6050_8h.html#a6074b2c5a2ea1df1f7f931d55e0bd711">Gyro_FS_t</a> MPU6050_Driver::MPU6050::GetGyroFullScale </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the gyroscope full scale range. Check gyro_full_scale_range_t for available scales. It basically reads the Gyro configuration register and returns the full scale range. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the sensor reading process </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">gyro_full_scale_range_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a63f6679d71e1968e463e7e8d419bdf49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f6679d71e1968e463e7e8d419bdf49">&#9670;&nbsp;</a></span>GetSensor_CurrentSampleRate_Hz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MPU6050_Driver::MPU6050::GetSensor_CurrentSampleRate_Hz </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current sensor sample rate. In order to do this, method reads Sample Rate Divider (0x19) and DLPF Config (0x1A) registers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td>Current sample rate in Hz </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4eadeb5b10c3e85e583248bb13d2618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4eadeb5b10c3e85e583248bb13d2618">&#9670;&nbsp;</a></span>GetSensor_DLPF_Config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="mpu6050_8h.html#a68026e723630e8ce2bd1eb0a16b1fdaf">DLPF_t</a> MPU6050_Driver::MPU6050::GetSensor_DLPF_Config </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the current sensor digital low pass filter configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">dlpf_config_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d7645b5c99d12af2b5c77b0f0cd4308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d7645b5c99d12af2b5c77b0f0cd4308">&#9670;&nbsp;</a></span>GetSensor_FIFO_Config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MPU6050_Driver::MPU6050::GetSensor_FIFO_Config </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sensor FIFO configuration. Use Regbits_FIFO_EN as bitmask to check which samples enabled in the FIFO reading. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint8_t</td><td>Sensor fifo configuration value, use Regbits_FIFO_EN to check fifo config. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a43ee2b1262daaaf93dc79e3c0f2cad59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ee2b1262daaaf93dc79e3c0f2cad59">&#9670;&nbsp;</a></span>GetSensor_FIFO_Data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MPU6050_Driver::MPU6050::GetSensor_FIFO_Data </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function reads 1 byte from sensor FIFO data register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint8_t</td><td>FIFO data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ea4952ae0e6844d2e08f5ebce7f89c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea4952ae0e6844d2e08f5ebce7f89c2">&#9670;&nbsp;</a></span>GetSensor_FIFO_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool MPU6050_Driver::MPU6050::GetSensor_FIFO_Enable </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sensor FIFO enable bit in USER_CTRL register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">bool</td><td>True if FIFO enabled </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad90893e458d8c6fe5a9a22c3c24c164c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90893e458d8c6fe5a9a22c3c24c164c">&#9670;&nbsp;</a></span>GetSensor_FIFOCount()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t MPU6050_Driver::MPU6050::GetSensor_FIFOCount </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the number of bytes written in the sensor FIFO buffers. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint16_t</td><td>Number of samples in the FIFO buffer in bytes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa66dcaf2d341a78c4ba4b6ce9fbf4cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66dcaf2d341a78c4ba4b6ce9fbf4cc8">&#9670;&nbsp;</a></span>GetSensor_InterruptEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MPU6050_Driver::MPU6050::GetSensor_InterruptEnable </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the INT_ENABLE register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint8_t</td><td>Enabled/Disabled sensor interrupts. Use Regbits_INT_ENABLE namespace as bitmask to check enabled interrupts. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a772cb0310b20811ac24b681fe3ecd4d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772cb0310b20811ac24b681fe3ecd4d0">&#9670;&nbsp;</a></span>GetSensor_InterruptPinConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MPU6050_Driver::MPU6050::GetSensor_InterruptPinConfig </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function returns sensor interrupt pin config register value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint8_t</td><td>Interrupt pin config register value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a87b2d31a71051e11e833ef2f4e9d1796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b2d31a71051e11e833ef2f4e9d1796">&#9670;&nbsp;</a></span>GetSensor_InterruptStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t MPU6050_Driver::MPU6050::GetSensor_InterruptStatus </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function gets the sensor interrput status (INT_STATUS) register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Result of the operation </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">uint8_t</td><td>Register value. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1311d6642dd43f9132598f7f84015954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1311d6642dd43f9132598f7f84015954">&#9670;&nbsp;</a></span>GetTemperature_Celcius()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float MPU6050_Driver::MPU6050::GetTemperature_Celcius </td>
          <td>(</td>
          <td class="paramtype">i2c_status_t *&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for getting the latest temperature value from the sensor. scale range is set to desired range, before reading the values. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">error</td><td>Error state of process </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">float</td><td>Temperature in celcius-degrees </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a267229ea1fc1e3d02eb503d068136fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267229ea1fc1e3d02eb503d068136fa8">&#9670;&nbsp;</a></span>InitializeSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::InitializeSensor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mpu6050_8h.html#a6074b2c5a2ea1df1f7f931d55e0bd711">Gyro_FS_t</a>&#160;</td>
          <td class="paramname"><em>gyroScale</em> = <code>Gyro_FS_t::FS_250_DPS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mpu6050_8h.html#adbb805fbc4ba6794ec6c603957b66f86">Accel_FS_t</a>&#160;</td>
          <td class="paramname"><em>accelScale</em> = <code>Accel_FS_t::FS_2G</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="mpu6050_8h.html#a68026e723630e8ce2bd1eb0a16b1fdaf">DLPF_t</a>&#160;</td>
          <td class="paramname"><em>DLPFconf</em> = <code>DLPF_t::BW_260Hz</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>SRdiv</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>INTconf</em> = <code>Regbits_INT_PIN_CFG::BIT_INT_RD_CLEAR</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>INTenable</em> = <code>Regbits_INT_ENABLE::BIT_DATA_RDY_EN</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>accelCalX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>accelCalY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>accelCalZ</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gyroCalX</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gyroCalY</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>gyroCalZ</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method wakes up the sensor and configures the accelerometer and gyroscope full scale renges with given parameters. It also configures the DLPF, sample rate divider, interrput configuration, and also calibrates the accelerometers and gyros. It returns the result of the process. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gyroScale</td><td>Gyroscope scale value to be set </td></tr>
    <tr><td class="paramname">accelScale</td><td>Accelerometer scale value to be set </td></tr>
    <tr><td class="paramname">DLPFconf</td><td>Digital Low Pass Filter configuration </td></tr>
    <tr><td class="paramname">SRdiv</td><td>Sample rate divider </td></tr>
    <tr><td class="paramname">INTconf</td><td>Interrupt configuration </td></tr>
    <tr><td class="paramname">INTenable</td><td>Interrput types enabled </td></tr>
    <tr><td class="paramname">accelCalX</td><td>Target acceleration in the X axis for calibration (units g) </td></tr>
    <tr><td class="paramname">accelCalY</td><td>Target acceleration in the Y axis for calibration (units g) </td></tr>
    <tr><td class="paramname">accelCalZ</td><td>Target acceleration in the Z axis for calibration (units g) </td></tr>
    <tr><td class="paramname">accelCalX</td><td>Target angular velocity in the X axis for calibration (units deg/s) </td></tr>
    <tr><td class="paramname">accelCalY</td><td>Target angular velocity in the Y axis for calibration (units deg/s) </td></tr>
    <tr><td class="paramname">accelCalZ</td><td>Target angular velocity in the Z axis for calibration (units deg/s) </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td>Success status </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ade93d7bce93550dcc0b1655f15e8e7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade93d7bce93550dcc0b1655f15e8e7c1">&#9670;&nbsp;</a></span>ReadAllRawData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::ReadAllRawData </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method will read all raw sensor data (accel, gyro, temp) into the rawData array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">None</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a279089d89ce308aab4e2ff4fed4478b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a279089d89ce308aab4e2ff4fed4478b1">&#9670;&nbsp;</a></span>Reset_Sensor_FIFO()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::Reset_Sensor_FIFO </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function resets the sensor FIFO. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a65e03c9cbdf0899f49fee4b0e4d01a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e03c9cbdf0899f49fee4b0e4d01a0e">&#9670;&nbsp;</a></span>ResetSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::ResetSensor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method resets the sensor by simply setting the REG_PWR_MGMT_1 Device_Reset bit. After the sensor reset this bit will be cleared automatically. </p>
<p>This method resets the sensor by simply setting the MPU6050_Regs::PWR_MGMT_1 Device_Reset bit. After the sensor reset this bit will be cleared automatically. TODO: Can be modify later to check the Device_Reset bit is clear after the reset in order to make it safer (for this we probably need an interface for platform delay function).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a307e5149054d25aa053c11438f782ad9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307e5149054d25aa053c11438f782ad9">&#9670;&nbsp;</a></span>SetAccel_X_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetAccel_X_Offset </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for setting the accelerometer X axis offset value. Offset is using in the sensor calibration routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d7703918ba2ac7f85942a27a6f7f039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7703918ba2ac7f85942a27a6f7f039">&#9670;&nbsp;</a></span>SetAccel_Y_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetAccel_Y_Offset </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for setting the accelerometer Y axis offset value. Offset is using in the sensor calibration routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a48b4595994f56460ef1cbd3ee69a9c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48b4595994f56460ef1cbd3ee69a9c52">&#9670;&nbsp;</a></span>SetAccel_Z_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetAccel_Z_Offset </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for setting the accelerometer Z axis offset value. Offset is using in the sensor calibration routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a050c46f31e9c88e95b744918afa00afd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050c46f31e9c88e95b744918afa00afd">&#9670;&nbsp;</a></span>SetAccelFullScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetAccelFullScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mpu6050_8h.html#adbb805fbc4ba6794ec6c603957b66f86">Accel_FS_t</a>&#160;</td>
          <td class="paramname"><em>accelScale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for configuring the accelerometer full scale range. Check accel_full_scale_range_t for available scales. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">accelScale</td><td>Accelerometer scale value to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abfe4393d5ad126f6734f8c090fd5e6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe4393d5ad126f6734f8c090fd5e6c7">&#9670;&nbsp;</a></span>SetGyro_SampleRateDivider()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetGyro_SampleRateDivider </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>sampleRate</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the gyroscope sample rate divider. Once the sample rate divider set, actual sample rate can be found with this formula: Actual sample rate = Gyroscope Output Rate / (1 + sampleRate) Keep in mind that Gyroscope Output Rate = 8kHz when the DLPF (digital low pass filter) is disabled (DLPF_CFG = 0 or 7), and 1kHz when the DLPF is enabled. Accel sample rate is constantly 1 kHz. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleRate</td><td>Gyroscope sample rate divider. <br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sampleRate</td><td>Gyroscope sample rate divider value </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab20bbcc5f584fe698060066d933e0081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab20bbcc5f584fe698060066d933e0081">&#9670;&nbsp;</a></span>SetGyro_X_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetGyro_X_Offset </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for setting the gyroscope X axis offset value. Offset is using in the sensor calibration routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5b64f45c3dc25303c0fbee8fa112e034"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b64f45c3dc25303c0fbee8fa112e034">&#9670;&nbsp;</a></span>SetGyro_Y_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetGyro_Y_Offset </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for setting the gyroscope Y axis offset value. Offset is using in the sensor calibration routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7803c59727c134c378f696ad1b25945d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7803c59727c134c378f696ad1b25945d">&#9670;&nbsp;</a></span>SetGyro_Z_Offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetGyro_Z_Offset </td>
          <td>(</td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for setting the gyroscope Z axis offset value. Offset is using in the sensor calibration routine. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab984441f83c718cf5c5c1bf019ea94ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab984441f83c718cf5c5c1bf019ea94ae">&#9670;&nbsp;</a></span>SetGyroFullScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetGyroFullScale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mpu6050_8h.html#a6074b2c5a2ea1df1f7f931d55e0bd711">Gyro_FS_t</a>&#160;</td>
          <td class="paramname"><em>gyroScale</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method used for configuring the gyroscope full scale range. Check gyro_full_scale_range_t for available scales. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">gyroScale</td><td>Gyroscope scale value to be set </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a94fd2a72ce9b39bd84dca9f6b10b0960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94fd2a72ce9b39bd84dca9f6b10b0960">&#9670;&nbsp;</a></span>SetSensor_DLPF_Config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetSensor_DLPF_Config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="mpu6050_8h.html#a68026e723630e8ce2bd1eb0a16b1fdaf">DLPF_t</a>&#160;</td>
          <td class="paramname"><em>dlpfConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sensor digital low pass filter values. Tighter bandwitdh configs will generate more delay on the sensor outputs (check sensor datasheet). Keep in mind that default Gyroscope sample rate is 8 kHz but if we set DLPF config different than 0 it will be 1 kHz by default unless if we make an extra configuration to Sample Rate Divider. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dlpfConfig</td><td>Digital low pass filter configuration value </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae7bc69264354de42675fe46789040aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7bc69264354de42675fe46789040aea">&#9670;&nbsp;</a></span>SetSensor_FIFO_Config()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetSensor_FIFO_Config </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>fifoConfigVal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sensor FIFO configuration. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fifoConfigVal</td><td>FIFO config value, use Regbits_FIFO_EN as bitmask to configure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abbde7961817c56ac32fe2f0303ccd920"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbde7961817c56ac32fe2f0303ccd920">&#9670;&nbsp;</a></span>SetSensor_FIFO_Enable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetSensor_FIFO_Enable </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sensor FIFO enable bit in USER_CTRL register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state</td><td>State of the FIFO to be set. True if it will be enabled. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae9eecdde5c431c18ba916e51bbb44c34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9eecdde5c431c18ba916e51bbb44c34">&#9670;&nbsp;</a></span>SetSensor_InterruptEnable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetSensor_InterruptEnable </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>enabledInterrupts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sensor INT_ENABLE register with given value. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">enabledInterrupts</td><td>Enabled/Disabled sensor interrupts. Use Regbits_INT_ENABLE namespace. </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acab75767c5515e9f57c04bc0635dc9f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab75767c5515e9f57c04bc0635dc9f5">&#9670;&nbsp;</a></span>SetSensor_InterruptPinConfig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::SetSensor_InterruptPinConfig </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>intPinConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function sets the sensor interrupt pin config register. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">intPinConfig</td><td>interrput pin config value to set </td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2b710e84411c3e041cf2bf7bd0faf8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b710e84411c3e041cf2bf7bd0faf8d9">&#9670;&nbsp;</a></span>WakeUpSensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">i2c_status_t MPU6050_Driver::MPU6050::WakeUpSensor </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method wakes the sensor up by cleraing the REG_PWR_MGMT_1 BIT_SLEEP. Power management 1 sensors default values is 0x40 so it will be in sleep mode when it's powered up. </p>
<p>This method wakes the sensor up by cleraing the MPU6050_Regs::PWR_MGMT_1 BIT_SLEEP. Power management 1 sensors default values is 0x40 so it will be in sleep mode when it's powered up.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">none</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="retval"><dt>Return values</dt><dd>
  <table class="retval">
    <tr><td class="paramname">i2c_status_t</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>lib/mpu6050/<a class="el" href="mpu6050_8h_source.html">mpu6050.h</a></li>
<li>lib/mpu6050/<a class="el" href="mpu6050_8cpp.html">mpu6050.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
